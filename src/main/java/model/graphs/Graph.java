package model.graphs;

import model.PlanningRequest;
import model.Request;
import model.graphs.pathfinding.Dijkstra;
import model.graphs.pathfinding.Edge;

import java.util.*;

public class Graph {
    private final Set<String> vertices;
    private final HashMap<Key, Edge> edges;
    private float minCost;
    private HashMap<Integer, Float> minSubgraphCost;

    /**
     * @param   plan the plan of the city
     * @return  the complete graph of the point of interests generated by dijkstra
     */
    public static Graph generateCompleteGraphFromPlan(Plan plan){
        Dijkstra dijkstra = new Dijkstra();
        List<String> pointsOfInterests = new ArrayList<>();

        PlanningRequest planningRequest = plan.getPlanningRequest();
        pointsOfInterests.add(planningRequest.getStartId());
        for (Request request: planningRequest.getRequests()) {
            pointsOfInterests.add(request.getDeliveryId());
            pointsOfInterests.add(request.getPickupId());
        }

        Graph newGraph = new Graph();


        for (String currentPoint:pointsOfInterests) {

            try{
                dijkstra.executeAlgorithm(plan,currentPoint,newGraph,pointsOfInterests );

            }catch (Exception e){
                System.err.println("Error creating the complete graph :"+ e.getMessage());
                return null;
            }
        }

        newGraph.calculateMinCost();
        return newGraph;
    }

    /**
     * calculate the minimal edge cost and store it
     */
    public void calculateMinCost(){
        minCost = Float.MAX_VALUE;
        for (Map.Entry<Key, Edge> entry : edges.entrySet()) {
            float duration = entry.getValue().getDuration();
            minCost = Math.min(minCost,duration);
        }
    }

    public Graph() {
        vertices = new HashSet<>();
        edges = new HashMap<>();
        minSubgraphCost = new HashMap<>();
    }

    /**
     * @param origin        the source vertex
     * @param destination   the destination vertex
     * @return              the cost of the source -> destination edge
     */
    public float getCost(String origin, String destination){
        Edge edge = edges.get(new Key(origin,destination));
        if(edge == null) {
            System.out.println(origin + " " + destination);

            return 0;
        }
        return edge.getDuration();
    }

    /**
     * @return the minimum edge cost of the graph
     */
    public float getMinCost(){
        return minCost;
    }


    /**
     * @param subGraph the subgraph
     * @return the minimum edge cost of the <code>subGraph</code>
     */
    public float getMinCost(List<String> subGraph){
        int hashcode = subGraph.stream()
                .mapToInt(Object::hashCode)
                .reduce(0, (left, right) -> left ^ right);
        if(minSubgraphCost.containsKey(hashcode))
            return minSubgraphCost.get(hashcode);

        float subGraphMinCost = Float.MAX_VALUE;
        for (Map.Entry<Key, Edge> entry : edges.entrySet()) {
            String x = entry.getKey().getX();
            String y = entry.getKey().getY();
            if(subGraph.contains(x) || subGraph.contains(y)){
                float duration = entry.getValue().getDuration();
                subGraphMinCost = Math.min(subGraphMinCost,duration);
            }
        }

        minSubgraphCost.put(hashcode, subGraphMinCost);
        return subGraphMinCost;
    }

    public Graph(Set<String> vertices, HashMap<Key, Edge> edges) {

        this.vertices = vertices;
        this.edges = edges;
    }

    /**
     * @param origin      the source vertex
     * @param destination the destination vertex
     * @param edge        the edge object
     */
    public void addEdge(String origin, String destination, Edge edge){
        vertices.add(origin);
        vertices.add(destination);
        edges.put(new Key(origin, destination),edge);
    }

    /**
     * @return the number of vertices in the graph
     */
    public int getNbVertices(){
        return vertices.size();
    }

    /**
     * @return the number of edges in the graph
     */
    public int getNbEdges(){
        return edges.size();
    }


    /**
     * @return the edges of the graph
     */
    public  HashMap<Key, Edge> getEdges(){
        return edges;
    }

    /**
     * @return the vertices of the graph
     */
    public Set<String> getVertices(){
        return vertices;
    }

    /**
     * @param node the current node to check neighbors of
     * @param vertices all the vertices of the graph
     * @return the nearest node of the currentNode
     */
    public String getNearestNodeFromNode(String node, Set<String>  vertices ){

        float minCost = Float.MAX_VALUE;
        String minNode = "";
        for (String vertex:vertices
        ) {
            if(!Objects.equals(node, vertex)){

                float cost =  getCost(node,vertex);
                if (cost < minCost){
                    minCost = cost;
                    minNode = vertex;
                }
            }
        }
        return minNode;
    }

    /**
     * @param origin        the source vertex
     * @param destination   the destination vertex
     * @return              true if we can go from <code>origin</code> to <code>destination</code>
     */
    public boolean isArc(String origin, String destination){
        return edges.containsKey(new Key(origin, destination));
    }


    /**
     * @param origin        the source vertex
     * @param destination   the destination vertex
     * @return              the edge of <code>origin</code>-><code>destination</code>
     */
    public Edge getEdge(String origin, String destination){
        return edges.get(new Key(origin, destination));
    }

}
